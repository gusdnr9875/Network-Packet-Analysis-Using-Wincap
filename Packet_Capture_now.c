#define _CRT_SECURE_NO_WARNINGS
#define WIN32
#pragma comment(lib, "wpcap.lib")
#pragma comment(lib, "ws2_32.lib")

#include <stdio.h>
#include <pcap\pcap.h>
#include <pcap.h>
#include <string.h>
#include <WinSock2.h>
#include <stdint.h>

#define IPHEADER 0x0800
#define ARPHEADER 0x0806
#define RARPHEADER 0x0835

/*이더넷 header 구조체*/
typedef struct Ethernet_Header
{
	u_char des[6];//수신자 MAC 주소
	u_char src[6];//송신자 MAC 주소
	short int ptype;//뒤에 나올 패킷의 프로토콜 종류(예:ARP/IP/RARP)
	   //IP 헤더가 오는 경우 : 0x0800
	   //ARP 헤더가 오는 경우 : 0x0806
	   //RARP 헤더가 오는 경우 : 0x0835
}Ethernet_Header;
/*Ip address 구조체*/
typedef struct ipaddress
{
	u_char ip1;
	u_char ip2;
	u_char ip3;
	u_char ip4;
}ip;
/*IP header 구조체*/
typedef struct IPHeader
{
	u_char HeaderLength : 4;//헤더 길이 *4
	u_char Version : 4;//IP v4 or IPv6
	u_char TypeOfService;//서비스 종류
	u_short TotalLength;//헤더 길이 + 데이터 길이/
	u_short ID;//프래그 먼트의 Identification
	u_short FlagOffset;//플래그 + 프래그먼트 오프셋

	u_char TimeToLive;//TimeToL
	u_char Protocol;//프로토콜 종류(1. ICMP 2. IGMP 6. TCP 17:UDP;
	u_short checksum;
	ip SenderAddress;
	ip DestinationAddress;
	u_int Option_Padding;

	// 추가
	unsigned short source_port;
	unsigned short dest_port;
}IPHeader; 
/*TCP header 구조체*/
typedef struct TCPHeader
{
	unsigned short source_port;
	unsigned short dest_port;
	unsigned int sequence;
	unsigned int acknowledge;
	unsigned char ns : 1;
	unsigned char reserved_part1 : 3;
	unsigned char data_offset : 4;
	unsigned char fin : 1;
	unsigned char syn : 1;
	unsigned char rst : 1;
	unsigned char psh : 1;
	unsigned char ack : 1;
	unsigned char urg : 1;
	unsigned char ecn : 1;
	unsigned char cwr : 1;
	unsigned short window;
	unsigned short checksum;
	unsigned short urgent_pointer;
}TCPHeader;
/*UDP header 구조체*/
typedef struct udp_hdr
{
	unsigned short source_port; // Source port no.
	unsigned short dest_port; // Dest. port no.
	unsigned short udp_length; // Udp packet length
	unsigned short udp_checksum; // Udp checksum (optional)

} UDP_HDR;
/*HTTP header 구조체*/
typedef struct HTTPHeader
{
	uint16_t HTP[16];

}HTTPHeader;
/*CheckSum 구조체*/
typedef struct CheckSummer
{
	u_short part1;
	u_short part2;
	u_short part3;
	u_short part4;
	u_short part5;
	u_short checksum;
	u_short part6;
	u_short part7;
	u_short part8;
	u_short part9;

}CheckSummer; 
/*DNS 구조체*/
typedef struct DNS
{
	u_char transaction_ID[2];
	u_char domain_name[40];

}domain;

/*필터링에 따라 관련 정보 핸들링*/
void packet_handler(u_char* param, const struct pcap_pkthdr* h, const u_char* data);
/*시간 출력*/
void print_first(const struct pcap_pkthdr* h, Ethernet_Header* EH);
/*패킷 정보 출력*/
void print_protocol(Ethernet_Header* EH, short int type, IPHeader* IH, TCPHeader* TCP, CheckSummer* CS);
/*ftp, */
void print_data(const u_char* data);
void print_packet_hex_data(u_char* data, int Size);

/*전역변수*/
u_int sel = 0;
char str_[20] = { 0, };

/***************************************/
/*                                     */
/*                 main                */
/*                                     */
/***************************************/

void main()
{
	pcap_if_t* allDevice; //찾아낸 디바이스를 LinkedList로 묶고, 그 중 첫 번째 오브젝트를 담을 변수 생성
	pcap_if_t* device; //Linked List의 다음 오브젝트를 담을 공간
	char errorMSG[256]; //에러 메시지를 담을 변수 생성
	char counter = 0;

	pcap_t* pickedDev; //사용할 디바이스를 저장하는 변수

		   //1. 장치 검색 (찾아낸 디바이스를 LinkedList로 묶음)
	if ((pcap_findalldevs(&allDevice, errorMSG)) == -1)//변수 생성시에는 1 포인터지만, pcap_findallDevice에 쓰는건 더블 포인트이므로 주소로 주어야 함.
					  //pcap_if_t는 int형태를 반환하며, -1이 나올 경우, 디바이스를 찾지 못했을 경우이다.
		printf("장치 검색 오류");

	//2. 장치 출력
	int count = 0;
	for (device = allDevice; device != NULL; device = device->next)
		//dev에 allDevice의 첫 시작 주소를 넣으며, dev의 값이 NULL(끝)일 경우 종료, dev는 매 for마다 다음 주소값으로 전환
	{
		printf("┏  %d 번 네트워크 카드━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\n", count);
		printf("┃ 어댑터 정보 : %s ┃\n", device->name);
		printf("┃ 어댑터 설명 : %s \n", device->description);
		printf("┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛\n");
		count = count + 1;
	}

	printf("패킷을 수집할 네트워크 카드 선택 >> ");
	device = allDevice;//카드를 선택하지 않고 그냥 첫 번째 카드로 설정

	int choice;
	scanf_s("%d", &choice);

	while (1) {
		printf("\n<필터링>\n");
		printf(" 1. ICMP\n 2. TCP\n 3. UDP\n 4. HTTP\n 5. FTP\n 6. DNS\n 7. ALL\n 8. IP로 검색\n");
		printf(" >> ");
		scanf_s("%d", &sel);
		if (sel == 1 || sel == 2 || sel == 3 || sel == 4 || sel == 5 || sel == 6 || sel == 7 || sel == 8) {
			break;
		}
		else {
			printf("다시입력\n");
		}
	}

	for (count = 0; count < choice; count++)
	{
		device = device->next;
	}

	//네트워크 장치를 열고, 수집할 패킷 양을 설정한다.
	pickedDev = pcap_open_live(device->name, 65536, 0, 1000, errorMSG);
	//랜카드의 이름, 수집할 패킷 크기(최대 65536), 프로미스큐어스모드(패킷 수집 모드) 설정, 패킷 대기 시간, 에러 정보를 저장할 공간)

	//4. 랜카드 리스트 정보를 저장한 메모리를 비워준다.
	pcap_freealldevs(allDevice);

	//5. 설정한 네트워크 카드에서 패킷을 무한 캡쳐 할 함수를 만들고 캡쳐를 시작한다.
	pcap_loop(pickedDev, 0, packet_handler, NULL);
}

/***************************************/
/*                                     */
/*            packet_handler           */
/*                                     */
/***************************************/
void packet_handler(u_char* param, const struct pcap_pkthdr* h, const u_char* data)
//인자 = 파라미터, 패킷 헤더, 패킷 데이터(수신자 MAC 주소 부분 부터)
{
	/*
	 * unused variables
	 */
	(VOID)(param);
	(VOID)(data);

	Ethernet_Header* EH = (Ethernet_Header*)data;//data 주소에 저장된 14byte 데이터가 구조체 Ethernet_Header 형태로 EH에 저장된다.
	short int type = ntohs(EH->ptype);
	//EH->ptype은 빅 엔디언 형식을 취하므로,
	//이를 리틀 엔디언 형식으로 변환(ntohs 함수)하여 type에 저장한다.
	IPHeader* IH = (struct IPHeader*)(data + 14); //제일 처음 14byte는 이더넷 헤더(Layer 2) 그 위에는 IP헤더(20byte), 그 위에는 TCP 헤더...
	TCPHeader* TCP = (struct TCPHeader*)(data + 34); // TCP 헤더 
	CheckSummer* CS = (struct CheckSummer*)(data + 14); //체크섬을 저장 할 변수
	domain* dns = (struct DNS*) (data + 42);
	UDP_HDR* UDP = (struct UDP_HDR*)(data + IH->HeaderLength * 4 + sizeof(Ethernet_Header));

	char ip_comp[20]; //ip 필터링용

	/* 1. ICMP 2. TCP 3. UDP 4. HTTP 5. FTP 6. ALL */
	switch (sel) {
	case 1: //ICMP
		if (IH->Protocol == IPPROTO_ICMP) {
			print_first(h, EH);
			print_protocol(EH, type, IH, TCP, CS);
			printf("┃\t세부 프로토콜 : ICMP               \n");
			printf("┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n");
		}
		break;
	case 2: //TCP
		if (IH->Protocol == IPPROTO_TCP) {
			print_first(h, EH);
			print_protocol(EH, type, IH, TCP, CS);

			printf("┃  --------------------------------------------  \n");
			printf("┃\t\t*[ TCP 헤더 ]*\t\t\n");
			printf("┃\tSCR PORT : %d\n", ntohs(TCP->source_port));
			printf("┃\tDEST PORT : %d\n", ntohs(TCP->dest_port));
			printf("┃\tSeg : %u\n", ntohl(TCP->sequence));
			printf("┃\tAck : %u\n", ntohl(TCP->acknowledge));
			printf("┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n");
		}
		break;
	case 3: //UDP
		if (IH->Protocol == IPPROTO_UDP) {
			print_first(h, EH);
			print_protocol(EH, type, IH, TCP, CS);

			printf("┃  --------------------------------------------  \n");
			printf("┃\t\t*[ UDP 헤더 ]*\t\t\n");
			printf("┃\tSCR PORT : %d\n", ntohs(UDP->source_port));
			printf("┃\tDEST PORT : %d\n", ntohs(UDP->dest_port));
			printf("┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n");
		}
		break;
	case 4: //HTTP
		if (IH->Protocol == IPPROTO_TCP) {
			if (ntohs(TCP->source_port) == 80 || ntohs(TCP->dest_port) == 80 || ntohs(TCP->source_port) == 443 || ntohs(TCP->dest_port) == 443) {
				print_first(h, EH);
				print_protocol(EH, type, IH, TCP, CS);
				 
				printf("┃  --------------------------------------------  \n");
				printf("┃\t\t*[ TCP 헤더 ]*\t\t\n");
				printf("┃\tSCR PORT : %d\n", ntohs(TCP->source_port));
				printf("┃\tDEST PORT : %d\n", ntohs(TCP->dest_port));
				printf("┃\tSeg : %u\n", ntohl(TCP->sequence));
				printf("┃\tAck : %u\n", ntohl(TCP->acknowledge));
				printf("┃\tHTTP 프로토콜 \n");
				uint8_t* packet = data + 34 + (IH->HeaderLength) * 4;
				printf("┃  ---------------HTTP Header-------------- \n");
				printf("┃\t%s \n", packet);
				printf("\n");
				printf("┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n");
			}
		}
		break;
	case 5: //FTP
		if (IH->Protocol == IPPROTO_TCP) {
			if (ntohs(TCP->source_port) == 21 || ntohs(TCP->dest_port) == 21) {

				print_first(h, EH);
				print_protocol(EH, type, IH, TCP, CS);
				printf("┃  --------------------------------------------  \n");
				printf("┃\t\t*[ TCP 헤더 ]*\t\t\n");
				printf("┃\tSCR PORT : %d\n", ntohs(TCP->source_port));
				printf("┃\tDEST PORT : %d\n", ntohs(TCP->dest_port));
				printf("┃\tSeg : %u\n", ntohl(TCP->sequence));
				printf("┃\tAck : %u\n", ntohl(TCP->acknowledge));
				printf("┃\tFTP 프로토콜 \n");
				u_char* packet_ = data + 34 + (IH->HeaderLength) * 4;
				printf("┃  --------------FTP DATA--------------\n");
				printf("┃\t%s \n", packet_);
				printf("┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n");
			}
		}
		break;
	case 6: //DNS
		if (ntohs(TCP->source_port) == 53 || ntohs(TCP->dest_port) == 53) {
			print_first(h, EH);
			print_protocol(EH, type, IH, TCP, CS);

			printf("┃  --------------------------------------------  \n");
			printf("┃\t\t*[ TCP 헤더 ]*\t\t\n");
			printf("┃\tSCR PORT : %d\n", ntohs(TCP->source_port));
			printf("┃\tDEST PORT : %d\n", ntohs(TCP->dest_port));
			printf("┃\tSeg : %u\n", ntohl(TCP->sequence));
			printf("┃\tAck : %u\n", ntohl(TCP->acknowledge));
			printf("┃\tDNS 프로토콜 \n");

			for (int i = 0; i < 40; i++) {
				if (dns->domain_name[i] > 60)
					printf("%c", dns->domain_name[i]);
				else if (dns->domain_name[i - 1] > 60)
					printf(".");
				if ((dns->domain_name[i - 2] == 'o' || dns->domain_name[i - 2] == 'k') && (dns->domain_name[i - 1] == 'm' || dns->domain_name[i - 1] == 'r') && dns->domain_name[i] < 60)
					break;
			}
			//printf("%s\n", dns->domain_name);
			printf("\n");
			printf("┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n");
		}
		break;
	case 7: //ALL
		print_first(h, EH);
		print_protocol(EH, type, IH, TCP, CS);

		switch (IH->Protocol) {
		case IPPROTO_ICMP: //ICMP
			printf("┃\t세부 프로토콜 : ICMP               \n");
		case IPPROTO_IGMP: //IGMP
			printf("┃\t세부 프로토콜 : IGMP              \n");
			break;
		case IPPROTO_TCP: //TCP
			printf("┃\t세부 프로토콜 : TCP              \n");
			printf("┃  --------------------------------------------  \n");
			printf("┃\t\t*[ TCP 헤더 ]*\t\t\n");
			printf("┃\tSCR PORT : %d\n", ntohs(TCP->source_port));
			printf("┃\tDEST PORT : %d\n", ntohs(TCP->dest_port));
			printf("┃\tSeg : %u\n", ntohl(TCP->sequence));
			printf("┃\tAck : %u\n", ntohl(TCP->acknowledge));

			/*FTP*/
			if (ntohs(TCP->source_port) == 21 || ntohs(TCP->dest_port) == 21) {
				printf("┃\tFTP 프로토콜 \n");
				u_char* packet_ = data + 34 + (IH->HeaderLength) * 4;
				printf("┃  --------------FTP DATA--------------\n");
				printf("┃\t%s \n", packet_);
			}

			/*HTTP*/
			if (ntohs(TCP->source_port) == 80 || ntohs(TCP->dest_port) == 80 || ntohs(TCP->source_port) == 443 || ntohs(TCP->dest_port) == 443) {
				printf("┃\tHTTP 프로토콜 \n");
				uint8_t* packet__ = data + 34 + (IH->HeaderLength) * 4;
				printf("┃  ---------------HTTP Header-------------- \n");
				printf("┃\t%s \n", packet__);
			}
			break;
		case IPPROTO_PUP:
			printf("┃\t세부 프로토콜 : PUP                                    \n");
			break;
		case IPPROTO_UDP: //UDP
			printf("┃\t세부 프로토콜 : UDP                    \n");
			break;
		case IPPROTO_IDP:
			printf("┃\t세부 프로토콜 : XNS IDP                                \n");
			break;
		case IPPROTO_PIM:
			printf("┃\t세부 프로토콜 : Independent Multicast                  \n");
			break;
		case IPPROTO_RAW:
			printf("┃\t세부 프로토콜 : Raw IP Packets                         \n");
			break;
		default:
			printf("┃\t세부 프로토콜 : Unknown                                \n");
		}
		printf("┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n");

		break;
	case 8: //IP 필터링
		if (str_[0] == 0) {
			printf("\nIP 입력 >> ");
			scanf_s("%s", str_);
			sprintf(ip_comp, "%d.%d.%d.%d", IH->SenderAddress.ip1, IH->SenderAddress.ip2, IH->SenderAddress.ip3, IH->SenderAddress.ip4);
		}
		if (strcmp(str_, ip_comp) == 0) {
			print_first(h, EH);
			print_protocol(EH, type, IH, TCP, CS);
			printf("┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n");
		}
		break;
	default:
		break;
	}
}

void print_first(const struct pcap_pkthdr* h, Ethernet_Header* EH) {
	struct tm ltime;
	char timestr[16];
	time_t local_tv_sec;

	/* convert the timestamp to readable format */
	local_tv_sec = h->ts.tv_sec;
	localtime_s(&ltime, &local_tv_sec);
	strftime(timestr, sizeof timestr, "%H:%M:%S", &ltime);
	printf("\n\n==================================================\n");
	printf("\tTime: %s,%.6d len:%d\n", timestr, h->ts.tv_usec, h->len);
	printf("\tNext Packet : %04x\n", EH->ptype);
}

void print_protocol(Ethernet_Header* EH, short int type, IPHeader* IH, TCPHeader* TCP, CheckSummer* CS) {

	printf("┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n");
	printf("┃\t\t*[ Ethernet 헤더 ]*\t\t\n");
	printf("┃\tSrc MAC : %02x-%02x-%02x-%02x-%02x-%02x\n", EH->src[0], EH->src[1], EH->src[2], EH->src[3], EH->src[4], EH->src[5]);//송신자 MAC
	printf("┃\tDst MAC : %02x-%02x-%02x-%02x-%02x-%02x\n", EH->des[0], EH->des[1], EH->des[2], EH->des[3], EH->des[4], EH->des[5]);//수신자 MAC
	printf("┃--------------------------------------------\n");

	//물리 계층은 01010101이므로 데이터 자르기는 안해도 됨.
	//헤더가 붙는 Layer2인 데이터링크 계층부터 자르면 됨.

	if (type == IPHEADER)
	{
		printf("┃\t\t*[ IP 헤더 ]*\n");
		printf("┃\tProtocol : IP\n");
		int partSum = ntohs(CS->part1) + ntohs(CS->part2) + ntohs(CS->part3) + ntohs(CS->part4) + ntohs(CS->part5) + ntohs(CS->part6) + ntohs(CS->part7) + ntohs(CS->part8) + ntohs(CS->part9);
		u_short Bit = partSum >> 16;
		printf("┃\t파트 합 : %08x\n", partSum);
		// printf("┃\t4칸 이동 : %08x\n", Bit);
		partSum = partSum - (Bit * 65536);
		// printf("┃\t넘긴것 더한 파트 합 : %04x\n", partSum + Bit);
		// printf("┃\t보수 취하기 : %04x\n", (u_short)~(partSum + Bit));
		printf("┃\t체크섬 : %04x\n", ntohs(CS->checksum));
		if (ntohs(CS->checksum) == (u_short)~(partSum + Bit))
			printf("┃\t손상되지 않은 정상 패킷입니다.\n");
		else
			printf("┃\t손상된 패킷입니다. 재전송 요청을 해야 합니다.\n");
		printf("┃\t버전 : IPv%d\n", IH->Version);
		printf("┃\t헤더 길이 : %d\n", (IH->HeaderLength) * 4);
		printf("┃\t서비스 종류 : %04x\n", IH->TypeOfService);
		printf("┃\t전체 크기 : %d\n", ntohs(IH->HeaderLength));//2 bytes 이상 부터는 무조건 뒤집어야 하므로 ntohs함수를 써서 뒤집는다.
		printf("┃\t프래그먼트 오프셋 : %d[byte]\n", (0x1FFF & ntohs(IH->FlagOffset) * 8));
		printf("┃\tTTL : %d\n", IH->TimeToLive);
		//  printf("┃\t체크섬 : %04x\n", ntohs(IH->checksum));//예) 0x145F
		printf("┃\t출발 IP 주소 : %d.%d.%d.%d\n", IH->SenderAddress.ip1, IH->SenderAddress.ip2, IH->SenderAddress.ip3, IH->SenderAddress.ip4);
		printf("┃\t도착 IP 주소 : %d.%d.%d.%d\n", IH->DestinationAddress.ip1, IH->DestinationAddress.ip2, IH->DestinationAddress.ip3, IH->DestinationAddress.ip4);
		//   printf("┃\t옵션/패딩 : %d\n", IH->Option_Padding);
		printf("\n");
		
		int iphdrlen = 0;
		iphdrlen = IH->HeaderLength * 64;

		print_packet_hex_data((u_char*)IH, iphdrlen);
	}
	else if (type == ARPHEADER)
	{
		printf("┃\tProtocol : ARP\n");
	}
	else if (type == RARPHEADER)
		printf("┃\tProtocol : RARP\n");
}

void print_data(const u_char* data) {
	printf("┃  ----------------DATA--------------\n");
	printf("┃\t%s \n", data);
}

void print_packet_hex_data(u_char* data, int Size)
{
	unsigned char a, line[17], c;
	int j;
	//loop over each character and print
	for (int i = 0; i < Size; i++)
	{
		c = data[i];
		//Print the hex value for every character , with a space
		printf(" %.2x", (unsigned int)c);
		//Add the character to data line
		a = (c >= 32 && c <= 128) ? (unsigned char)c : '.';
		line[i % 16] = a;
		//if last character of a line , then print the line - 16 characters in 1 line
		if ((i != 0 && (i + 1) % 16 == 0) || i == Size - 1)
		{
			line[i % 16 + 1] = '\0';
			//print a big gap of 10 characters between hex and characters
			printf("          ");
			//Print additional spaces for last lines which might be less than 16 characters in length
			for (j = strlen((const char*)line); j < 16; j++)
			{
				printf("   ");
			}
			printf("%s \n", line);
		}
	}
	printf("\n");
}
